关系范式解决数据存储重复问题
第一范式：属性是原子的，不可再分割的
第二范式：非主属性完全依赖于候选键（不能部分依赖）
第三范式：属性间不能有传递依赖
BC范式 ： 主属性之间没有依赖
第四范式：


MySQL

从加锁粒度分类
表级锁：开销小，加锁快，不会出现死锁；锁定力度大，锁冲突概率高，并发度低。
行级锁：开销大，加锁慢；会出现死锁  ；锁定粒度小，锁冲突概率低，并发度高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

从锁的模式分类
共享锁（读锁）
独占锁（写锁）

MyIsam
使用表级所

InnoDB
支持事务
使用行级锁（依赖于索引）
    InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁。

    对于范围条件的检索请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁。比如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：
    SELECT * FROM emp WHERE empid > 100 FOR UPDATE
    InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。

