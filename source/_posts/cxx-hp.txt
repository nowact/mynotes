0. 先定位
   打点
   valgrind等性能检查工具
   perf 
   linux /proc/<pid> 目录下的统计数据

1. 选择正确的数据结构和算法
   避免STL扩容时的内存移动、复制

2. 减少内存拷贝
   C++11 std::vector emplace
   io分散读、集中写

3. 分支预测 ___builtin_expect(exp, c)
      使用模板编译期确定执行顺序，避免if else运行时判断
   减少CPU Cache失效
      多使用局部变量，少使用全局变量
      把一个函数中访问到的不同字段定义到一个结构体中
	  二维数组先取行再取列
      线程绑定CPU
      数据定义和cache line对齐(64字节)
      线程之间避免访问相邻的数据, 例如a[8], 然后每个线程访问固定一个下标来访问, 并且存在写操作, 这样会使效率暴降, 除非把a的数据类型是按CPU的cacheline大小定义的.
	  
	  多线程访问一个字段较多的结构体，结构体定义中使用字节对齐指令分割被线程访问的不同部分。
	  
	  
    prefetch 指令

3.2 避免用户态到内核态的切换
    缺页中断
	linux上new或malloc分配的内存，不会立刻映射到物理内存，对内存写的时候才执行映射
	clock_gettime不会陷入内核调用

4. 线程的使用
   多线程并发充分利用多核资源
   避免过多加锁，防止拖累并发
   避免线程过多，减少线程调度开销
   线程绑定cpu core

5. 网络数据收发性能
   独立的网络IO线程
   分散读，集中写
   调整tcp相关内核参数
   tcpdump排查与验证问题

4. 无符号信息分析coredump文件

5. S卡、FPEG

# Interrupt
synchronous interrupt
    generated by executing an instruction, usually named exceptions
	detected by the processor itself in the course of executing an instruction.
	Divide by zero or a system call are examples of exceptions.

asynchronous interrupt
	generated by external I/O devices events.
	For example a network card generates an interrupts to signal that a packet has arrived.

# 可中断与不可中断睡眠

Linux has two fundamental ways in which a process can be put to sleep. A process which is placed in the TASK_INTERRUPTIBLE state will sleep until either (1) something explicitly wakes it up, or (2) a non-masked signal is received. The TASK_UNINTERRUPTIBLE state, instead, ignores signals; processes in that state will require an explicit wakeup before they can run again.

# Context switching

Context switching can happen for two reasons. First one is the genuine processor switches, guided by the kernel scheduler. Second one is due to interrupts caused by hard wares and other software applications.


# Affinity
By default a process uses all the individual processors(cores).
Note that the Linux scheduler also supports natural CPU affinity: the scheduler attempts to keep processes on the same CPU as long as practical for performance reasons.  Therefore, forcing a specific CPU affinity is useful only in certain applications.

The  isolcpus  boot  option  can  be  used to isolate one or more CPUs at boot time, so that no processes are scheduled onto those CPUs.  Following the use of this boot option, the only way to schedule processes onto the isolated CPUs is via sched_setaffinity() or the cpuset(7) mechanism.  For further information, see the kernel source file  Documentation/kernel-parameters.txt.  As noted in that file, isolcpus is the preferred mechanism of isolating CPUs (versus the alternative of manually setting the CPU affinity of all processes on the system).
	   
查看一个进程的affinity
taskset -c -p <pid>

设置一个进程绑定到cpu0, 1, 2
taskset -c 0,1,2 -p <pid>

man sched_setaffinity
man sched_setscheduler
man 7 sched
man 7 cpuset
